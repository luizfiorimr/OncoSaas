---
alwaysApply: true
description: Regras de desenvolvimento para manter consistência, modularidade e seguir melhores práticas em todo o projeto. Guia completo para arquitetura, padrões de código, estrutura de módulos e integração entre serviços.
---

# Regras de Desenvolvimento - Modularidade e Boas Práticas

## Princípios Fundamentais

### 1. Modularidade e Separação de Responsabilidades

**Regra**: Cada módulo/serviço deve ter uma responsabilidade única e bem definida.

**Aplicação**:
- **Frontend**: Apenas apresentação e interação do usuário
- **Backend**: Lógica de negócio e orquestração
- **AI Service**: Processamento de IA/ML e agente conversacional
- **Database**: Apenas persistência de dados

**Nunca**:
- ❌ Colocar lógica de negócio no frontend
- ❌ Fazer chamadas diretas a APIs externas do frontend (exceto públicas)
- ❌ Misturar lógica de IA com lógica de negócio no backend
- ❌ Acessar banco de dados diretamente do frontend

**Sempre**:
- ✅ Frontend → Backend → Database
- ✅ Backend → AI Service → Retorna resultado
- ✅ Cada serviço tem sua própria responsabilidade

---

### 2. Multi-Tenancy e Isolamento de Dados

**Regra**: Todos os dados devem ser isolados por tenant (hospital/clínica).

**Implementação**:
- **Schema por tenant**: Cada tenant tem seu próprio schema no PostgreSQL
- **Middleware obrigatório**: Todas as queries devem incluir `tenantId`
- **Validação**: Sempre validar `tenantId` em todas as operações
- **Erro**: Retornar 403 se tentar acessar dados de outro tenant

**Exemplo**:
```typescript
// ✅ CORRETO
const patients = await prisma.patient.findMany({
  where: {
    tenantId: req.user.tenantId, // SEMPRE incluir tenantId
    id: patientId
  }
});

// ❌ ERRADO
const patients = await prisma.patient.findMany({
  where: { id: patientId } // FALTA tenantId!
});
```

---

### 3. Type Safety e TypeScript

**Regra**: TypeScript é obrigatório em todo o projeto. Evitar `any` e `unknown` sem validação.

**Padrões**:
- ✅ Sempre definir tipos explícitos para funções públicas
- ✅ Usar interfaces para contratos entre módulos
- ✅ Validar dados de entrada com Zod ou class-validator
- ✅ Usar tipos do Prisma gerados (`Prisma.Patient`, etc.)

**Exemplo**:
```typescript
// ✅ CORRETO
interface CreatePatientDto {
  name: string;
  dateOfBirth: Date;
  tenantId: string;
}

async function createPatient(dto: CreatePatientDto): Promise<Patient> {
  // ...
}

// ❌ ERRADO
async function createPatient(dto: any): Promise<any> {
  // ...
}
```

---

## Estrutura de Pastas e Organização

### Frontend (Next.js 14 - App Router)

```
frontend/
├── src/
│   ├── app/                    # App Router (rotas)
│   │   ├── (auth)/            # Grupo de rotas (auth)
│   │   ├── dashboard/         # Rotas do dashboard
│   │   └── layout.tsx         # Layout raiz
│   ├── components/            # Componentes React
│   │   ├── ui/                # Componentes UI básicos (shadcn)
│   │   ├── dashboard/         # Componentes específicos do dashboard
│   │   └── shared/            # Componentes compartilhados
│   ├── lib/                   # Utilitários e helpers
│   │   ├── api/               # Clientes de API
│   │   ├── utils/             # Funções utilitárias
│   │   └── validations/       # Schemas Zod
│   ├── hooks/                 # Custom hooks React
│   ├── stores/                # Zustand stores (state management)
│   └── types/                 # TypeScript types/interfaces
├── public/                    # Arquivos estáticos
└── package.json
```

**Regras**:
- ✅ Um componente por arquivo
- ✅ Componentes em PascalCase (`PatientList.tsx`)
- ✅ Hooks começam com `use` (`usePatients.ts`)
- ✅ Utilitários em camelCase (`formatDate.ts`)
- ✅ Types em PascalCase (`Patient.ts`, `ApiResponse.ts`)

---

### Backend (NestJS)

```
backend/
├── src/
│   ├── modules/               # Módulos NestJS (um por feature)
│   │   ├── patients/          # Módulo de pacientes
│   │   │   ├── patients.controller.ts
│   │   │   ├── patients.service.ts
│   │   │   ├── patients.module.ts
│   │   │   ├── dto/           # Data Transfer Objects
│   │   │   │   ├── create-patient.dto.ts
│   │   │   │   └── update-patient.dto.ts
│   │   │   └── entities/      # Entidades (opcional, se não usar Prisma)
│   │   ├── conversations/     # Módulo de conversas WhatsApp
│   │   ├── alerts/            # Módulo de alertas
│   │   └── auth/              # Módulo de autenticação
│   ├── common/                # Código compartilhado
│   │   ├── decorators/        # Decorators customizados
│   │   ├── filters/           # Exception filters
│   │   ├── guards/            # Guards (auth, roles)
│   │   ├── interceptors/      # Interceptors
│   │   ├── pipes/             # Pipes (validação, transformação)
│   │   └── middleware/        # Middleware global
│   ├── config/                # Configurações
│   ├── prisma/                # Prisma service e module
│   └── main.ts                # Entry point
├── prisma/
│   ├── schema.prisma          # Schema do banco
│   └── migrations/            # Migrations
└── package.json
```

**Regras**:
- ✅ Um módulo por feature/domínio
- ✅ Cada módulo tem: `*.module.ts`, `*.service.ts`, `*.controller.ts`
- ✅ DTOs em pastas separadas (`dto/`)
- ✅ Services contêm lógica de negócio
- ✅ Controllers apenas roteamento e validação de entrada

**Estrutura de um Módulo**:
```typescript
// patients.module.ts
@Module({
  imports: [PrismaModule],
  controllers: [PatientsController],
  providers: [PatientsService],
  exports: [PatientsService], // Exportar se usado em outros módulos
})
export class PatientsModule {}

// patients.service.ts
@Injectable()
export class PatientsService {
  constructor(private prisma: PrismaService) {}

  async findAll(tenantId: string): Promise<Patient[]> {
    return this.prisma.patient.findMany({
      where: { tenantId }, // SEMPRE incluir tenantId
    });
  }
}

// patients.controller.ts
@Controller('patients')
@UseGuards(JwtAuthGuard, TenantGuard) // Guards obrigatórios
export class PatientsController {
  constructor(private patientsService: PatientsService) {}

  @Get()
  async findAll(@Request() req): Promise<Patient[]> {
    return this.patientsService.findAll(req.user.tenantId);
  }
}
```

---

### AI Service (FastAPI)

```
ai-service/
├── src/
│   ├── api/                   # Rotas FastAPI
│   │   ├── routes/           # Rotas agrupadas
│   │   │   ├── priority.py   # Rotas de priorização
│   │   │   ├── agent.py      # Rotas do agente WhatsApp
│   │   │   └── health.py     # Health check
│   │   └── dependencies.py   # Dependencies (auth, tenant)
│   ├── models/                # Modelos ML
│   │   ├── priority_model.py # Modelo de priorização
│   │   └── __init__.py
│   ├── agent/                 # Lógica do agente conversacional
│   │   ├── whatsapp_agent.py # Agente principal
│   │   ├── rag.py            # RAG (Retrieval Augmented Generation)
│   │   ├── guardrails.py     # Validação de respostas
│   │   └── stt.py            # Speech-to-Text
│   ├── services/              # Serviços auxiliares
│   │   ├── llm_service.py    # Cliente LLM (OpenAI/Anthropic)
│   │   └── embeddings.py     # Embeddings para RAG
│   ├── schemas/               # Pydantic schemas (validação)
│   │   ├── priority.py
│   │   └── conversation.py
│   └── utils/                 # Utilitários
├── main.py                    # Entry point FastAPI
└── requirements.txt
```

**Regras**:
- ✅ Rotas agrupadas por funcionalidade
- ✅ Schemas Pydantic para validação de entrada/saída
- ✅ Services separados da lógica de rota
- ✅ Modelos ML em pastas separadas
- ✅ Funções async quando possível

**Exemplo**:
```python
# api/routes/priority.py
from fastapi import APIRouter, Depends
from src.schemas.priority import PriorityRequest, PriorityResponse
from src.models.priority_model import PriorityModel

router = APIRouter(prefix="/priority", tags=["priority"])

@router.post("/calculate", response_model=PriorityResponse)
async def calculate_priority(
    request: PriorityRequest,
    tenant_id: str = Depends(get_tenant_id)  # Dependency injection
):
    model = PriorityModel()
    result = await model.predict(request)
    return PriorityResponse(score=result.score, category=result.category)
```

---

## Convenções de Nomenclatura

### TypeScript/JavaScript

**Arquivos**:
- ✅ Componentes React: `PascalCase.tsx` (`PatientList.tsx`)
- ✅ Hooks: `camelCase.ts` com prefixo `use` (`usePatients.ts`)
- ✅ Utilitários: `camelCase.ts` (`formatDate.ts`)
- ✅ Types/Interfaces: `PascalCase.ts` (`Patient.ts`)
- ✅ Constantes: `UPPER_SNAKE_CASE.ts` (`API_ENDPOINTS.ts`)

**Variáveis e Funções**:
- ✅ Variáveis: `camelCase` (`patientName`, `isLoading`)
- ✅ Funções: `camelCase` (`getPatient`, `calculatePriority`)
- ✅ Classes: `PascalCase` (`PatientService`, `PriorityModel`)
- ✅ Constantes: `UPPER_SNAKE_CASE` (`MAX_RETRIES`, `API_BASE_URL`)
- ✅ Privadas: Prefixo `_` (`_internalMethod`)

**Exemplo**:
```typescript
// ✅ CORRETO
const PATIENT_STATUS = {
  ACTIVE: 'active',
  IN_TREATMENT: 'in_treatment',
} as const;

interface Patient {
  id: string;
  name: string;
  tenantId: string;
}

async function getPatientById(id: string, tenantId: string): Promise<Patient> {
  // ...
}
```

---

### Python

**Arquivos**:
- ✅ Módulos: `snake_case.py` (`priority_model.py`, `whatsapp_agent.py`)
- ✅ Classes: `PascalCase` (`PriorityModel`, `WhatsAppAgent`)

**Variáveis e Funções**:
- ✅ Variáveis: `snake_case` (`patient_name`, `is_loading`)
- ✅ Funções: `snake_case` (`get_patient`, `calculate_priority`)
- ✅ Classes: `PascalCase` (`PatientService`, `PriorityModel`)
- ✅ Constantes: `UPPER_SNAKE_CASE` (`MAX_RETRIES`, `API_BASE_URL`)
- ✅ Privadas: Prefixo `_` (`_internal_method`)

**Exemplo**:
```python
# ✅ CORRETO
MAX_RETRIES = 3
API_BASE_URL = "https://api.example.com"

class PatientService:
    def __init__(self, tenant_id: str):
        self._tenant_id = tenant_id  # Privado
    
    async def get_patient(self, patient_id: str) -> Patient:
        # ...
        pass
```

---

## Padrões de API e Comunicação

### REST API (Backend)

**Endpoints**:
- ✅ `GET /api/v1/patients` - Listar pacientes
- ✅ `GET /api/v1/patients/:id` - Obter paciente específico
- ✅ `POST /api/v1/patients` - Criar paciente
- ✅ `PUT /api/v1/patients/:id` - Atualizar paciente completo
- ✅ `PATCH /api/v1/patients/:id` - Atualizar paciente parcial
- ✅ `DELETE /api/v1/patients/:id` - Deletar paciente

**Versionamento**:
- ✅ Sempre usar `/api/v1/` no path
- ✅ Incrementar versão quando houver breaking changes

**Respostas**:
- ✅ Sucesso: Status 200 (GET), 201 (POST), 204 (DELETE)
- ✅ Erro: Status 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 500 (Internal Server Error)
- ✅ Formato consistente: `{ data: T }` ou `{ error: { message: string, code: string } }`

**Exemplo**:
```typescript
// ✅ CORRETO
@Get(':id')
async findOne(
  @Param('id') id: string,
  @Request() req
): Promise<ApiResponse<Patient>> {
  const patient = await this.patientsService.findOne(id, req.user.tenantId);
  
  if (!patient) {
    throw new NotFoundException('Patient not found');
  }
  
  return {
    data: patient,
  };
}
```

---

### Comunicação Frontend ↔ Backend

**Cliente de API**:
- ✅ Criar cliente centralizado (`lib/api/client.ts`)
- ✅ Usar interceptors para adicionar token JWT
- ✅ Tratamento de erros centralizado
- ✅ TypeScript types para todas as respostas

**Exemplo**:
```typescript
// lib/api/client.ts
import axios from 'axios';

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Interceptor para adicionar token
apiClient.interceptors.request.use((config) => {
  const token = getToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Interceptor para tratamento de erros
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirecionar para login
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

---

### Comunicação Backend ↔ AI Service

**Padrão**:
- ✅ Backend faz requisições HTTP para AI Service
- ✅ Usar cliente HTTP (axios) com retry e circuit breaker
- ✅ Timeout configurado (ex: 30s)
- ✅ Tratamento de erros (fallback se AI Service indisponível)

**Exemplo**:
```typescript
// backend/src/services/ai-service.client.ts
@Injectable()
export class AIServiceClient {
  private readonly client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: process.env.AI_SERVICE_URL,
      timeout: 30000,
    });
  }

  async calculatePriority(data: PriorityRequest): Promise<PriorityResponse> {
    try {
      const response = await this.client.post('/api/v1/priority/calculate', data);
      return response.data;
    } catch (error) {
      // Fallback: retornar prioridade média se AI Service falhar
      logger.error('AI Service unavailable', error);
      return { score: 50, category: 'medium' };
    }
  }
}
```

---

## Segurança e Compliance

### Autenticação e Autorização

**Regras**:
- ✅ JWT obrigatório para todas as rotas protegidas
- ✅ Refresh token para renovação
- ✅ MFA obrigatório para profissionais de saúde
- ✅ Validação de tenant em todas as operações
- ✅ RBAC (Role-Based Access Control): admin, oncologista, enfermeiro, gestor

**Implementação**:
```typescript
// ✅ CORRETO - Guard para autenticação
@UseGuards(JwtAuthGuard, TenantGuard)
@Controller('patients')
export class PatientsController {
  // ...
}

// ✅ CORRETO - Guard para roles
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('nurse', 'oncologist')
@Get('alerts')
async getAlerts(@Request() req) {
  // ...
}
```

---

### Validação de Dados

**Regras**:
- ✅ Sempre validar dados de entrada
- ✅ Backend: class-validator (NestJS) ou Zod
- ✅ Frontend: Zod schemas para validação de formulários
- ✅ AI Service: Pydantic schemas

**Exemplo**:
```typescript
// ✅ CORRETO - DTO com validação
export class CreatePatientDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsDate()
  @Type(() => Date)
  dateOfBirth: Date;

  @IsString()
  @IsIn(['male', 'female', 'other'])
  gender: string;

  @IsUUID()
  tenantId: string;
}
```

---

### Criptografia e Dados Sensíveis

**Regras**:
- ✅ Dados de saúde sempre criptografados em repouso (AES-256)
- ✅ TLS 1.3 obrigatório em trânsito
- ✅ Conversas WhatsApp armazenadas criptografadas
- ✅ Senhas sempre hasheadas (bcrypt ou Argon2)
- ✅ Nunca logar dados sensíveis (senhas, tokens, dados de saúde)

**Exemplo**:
```typescript
// ✅ CORRETO - Hash de senha
import * as bcrypt from 'bcrypt';

const hashedPassword = await bcrypt.hash(password, 10);

// ✅ CORRETO - Criptografia de dados sensíveis
import * as crypto from 'crypto';

function encryptSensitiveData(data: string, key: string): string {
  const cipher = crypto.createCipher('aes-256-gcm', key);
  // ...
}
```

---

## Testes

### Estrutura de Testes

**Frontend**:
- ✅ Testes unitários: `*.test.tsx` ou `*.spec.tsx`
- ✅ Testes de componentes: React Testing Library
- ✅ Testes E2E: Playwright ou Cypress

**Backend**:
- ✅ Testes unitários: Jest
- ✅ Testes de integração: Supertest (testar rotas)
- ✅ Testes E2E: Testes completos de fluxo

**AI Service**:
- ✅ Testes unitários: pytest
- ✅ Testes de integração: Testar APIs FastAPI

**Regras**:
- ✅ Cobertura mínima: 70% (objetivo: 80%+)
- ✅ Testes devem ser independentes (não depender de ordem)
- ✅ Mock de dependências externas (APIs, banco de dados)
- ✅ Testes devem ser rápidos (< 1s unitários, < 10s integração)

**Exemplo**:
```typescript
// ✅ CORRETO - Teste unitário
describe('PatientsService', () => {
  it('should return patients filtered by tenant', async () => {
    const mockPrisma = {
      patient: {
        findMany: jest.fn().mockResolvedValue([mockPatient]),
      },
    };
    
    const service = new PatientsService(mockPrisma);
    const result = await service.findAll('tenant-1');
    
    expect(mockPrisma.patient.findMany).toHaveBeenCalledWith({
      where: { tenantId: 'tenant-1' },
    });
    expect(result).toEqual([mockPatient]);
  });
});
```

---

## Logging e Monitoramento

### Logging

**Regras**:
- ✅ Usar logger estruturado (Winston, Pino)
- ✅ Níveis: error, warn, info, debug
- ✅ Sempre incluir contexto (tenantId, userId, requestId)
- ✅ Nunca logar dados sensíveis
- ✅ Logs de auditoria imutáveis (LGPD)

**Exemplo**:
```typescript
// ✅ CORRETO
logger.info('Patient created', {
  patientId: patient.id,
  tenantId: patient.tenantId,
  userId: req.user.id,
  requestId: req.id,
});

// ❌ ERRADO - Logar dados sensíveis
logger.info('Patient created', { patient }); // Pode conter dados sensíveis
```

---

### Tratamento de Erros

**Regras**:
- ✅ Erros sempre tipados (custom exceptions)
- ✅ Mensagens de erro não expor detalhes internos
- ✅ Logar detalhes completos no servidor
- ✅ Retornar mensagens amigáveis ao cliente

**Exemplo**:
```typescript
// ✅ CORRETO - Exception customizada
export class PatientNotFoundException extends NotFoundException {
  constructor(patientId: string) {
    super(`Patient with ID ${patientId} not found`);
  }
}

// ✅ CORRETO - Tratamento centralizado
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    
    logger.error('Exception caught', {
      exception,
      stack: exception.stack,
    });
    
    response.status(500).json({
      error: {
        message: 'Internal server error',
        code: 'INTERNAL_ERROR',
      },
    });
  }
}
```

---

## Performance e Otimização

### Database

**Regras**:
- ✅ Sempre usar índices em campos de busca frequente (`tenantId`, `patientId`)
- ✅ Evitar N+1 queries (usar `include` do Prisma)
- ✅ Paginação obrigatória em listas grandes
- ✅ Cache de queries frequentes (Redis)

**Exemplo**:
```typescript
// ✅ CORRETO - Evitar N+1
const patients = await prisma.patient.findMany({
  where: { tenantId },
  include: {
    conversations: true, // Carregar relacionamentos de uma vez
  },
  take: 20, // Paginação
  skip: 0,
});

// ❌ ERRADO - N+1 query
const patients = await prisma.patient.findMany({ where: { tenantId } });
for (const patient of patients) {
  patient.conversations = await prisma.conversation.findMany({
    where: { patientId: patient.id },
  }); // Query dentro de loop!
}
```

---

### Frontend

**Regras**:
- ✅ Lazy loading de componentes pesados
- ✅ Code splitting por rota
- ✅ Otimização de imagens (Next.js Image)
- ✅ Cache de dados com React Query
- ✅ Debounce em buscas

**Exemplo**:
```typescript
// ✅ CORRETO - Lazy loading
const HeavyComponent = lazy(() => import('./HeavyComponent'));

// ✅ CORRETO - React Query cache
const { data } = useQuery({
  queryKey: ['patients', tenantId],
  queryFn: () => fetchPatients(tenantId),
  staleTime: 5 * 60 * 1000, // Cache por 5 minutos
});
```

---

## Documentação

### Código

**Regras**:
- ✅ JSDoc/TSDoc para funções públicas
- ✅ Comentários explicam "por quê", não "o quê"
- ✅ README em cada módulo/serviço
- ✅ Documentação de API (Swagger/OpenAPI)

**Exemplo**:
```typescript
/**
 * Calcula o score de prioridade de um paciente baseado em múltiplos fatores.
 * 
 * @param patient - Dados do paciente incluindo sintomas e histórico
 * @param tenantId - ID do tenant para isolamento de dados
 * @returns Score de prioridade (0-100) e categoria
 * 
 * @example
 * const result = await calculatePriority(patient, 'tenant-1');
 * // { score: 85, category: 'high' }
 */
async function calculatePriority(
  patient: Patient,
  tenantId: string
): Promise<PriorityResult> {
  // ...
}
```

---

### API Documentation

**Regras**:
- ✅ Swagger/OpenAPI para todas as APIs REST
- ✅ Exemplos de requisição/resposta
- ✅ Descrição de cada endpoint
- ✅ Schemas de validação documentados

**Exemplo**:
```typescript
// ✅ CORRETO - Swagger decorators (NestJS)
@ApiTags('patients')
@Controller('patients')
export class PatientsController {
  @Get(':id')
  @ApiOperation({ summary: 'Get patient by ID' })
  @ApiParam({ name: 'id', type: 'string' })
  @ApiResponse({ status: 200, type: Patient })
  @ApiResponse({ status: 404, description: 'Patient not found' })
  async findOne(@Param('id') id: string): Promise<Patient> {
    // ...
  }
}
```

---

## Git e Versionamento

### Commits

**Regras**:
- ✅ Commits atômicos (uma mudança por commit)
- ✅ Mensagens descritivas em português
- ✅ Formato: `tipo(escopo): descrição`
- ✅ Tipos: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`

**Exemplo**:
```
feat(patients): adiciona endpoint para listar pacientes por tenant
fix(auth): corrige validação de token JWT expirado
docs(api): atualiza documentação Swagger
refactor(ai-service): refatora modelo de priorização
test(patients): adiciona testes unitários para PatientsService
chore(deps): atualiza dependências do projeto
```

---

### Branches

**Regras**:
- ✅ `main`: Código em produção
- ✅ `develop`: Código em desenvolvimento
- ✅ `feature/nome-da-feature`: Features novas
- ✅ `fix/nome-do-bug`: Correções de bugs
- ✅ `hotfix/nome-do-hotfix`: Correções urgentes

**Workflow**:
1. Criar branch a partir de `develop`
2. Desenvolver feature
3. Criar Pull Request para `develop`
4. Code review obrigatório
5. Merge após aprovação
6. Deploy para staging
7. Após validação, merge para `main`

---

## Checklist Antes de Commitar

Antes de fazer commit, verificar:

- [ ] Código compila sem erros
- [ ] Testes passando (unitários e integração)
- [ ] Linter sem erros (`npm run lint` ou `pylint`)
- [ ] TypeScript sem erros (`npm run type-check`)
- [ ] Cobertura de testes mantida ou aumentada
- [ ] Documentação atualizada (se necessário)
- [ ] Migrations criadas (se mudou schema)
- [ ] Variáveis de ambiente documentadas (se novas)
- [ ] Código revisado (self-review)
- [ ] Mensagem de commit descritiva

---

## Recursos e Referências

### Documentação Oficial

- **Next.js**: https://nextjs.org/docs
- **NestJS**: https://docs.nestjs.com
- **FastAPI**: https://fastapi.tiangolo.com
- **Prisma**: https://www.prisma.io/docs
- **TypeScript**: https://www.typescriptlang.org/docs
- **Python**: https://docs.python.org/3/

### Guias de Estilo

- **TypeScript**: https://github.com/microsoft/TypeScript/wiki/Coding-guidelines
- **Python PEP 8**: https://pep8.org/
- **React**: https://react.dev/learn/thinking-in-react
- **NestJS Best Practices**: https://docs.nestjs.com/recipes/cqrs

### Ferramentas

- **ESLint**: Linter para TypeScript/JavaScript
- **Prettier**: Formatação de código
- **Husky**: Git hooks (pre-commit, pre-push)
- **lint-staged**: Lint apenas arquivos staged

---

## Resumo das Regras Críticas

1. ✅ **Modularidade**: Cada módulo tem responsabilidade única
2. ✅ **Multi-tenancy**: Sempre incluir `tenantId` em queries
3. ✅ **Type Safety**: TypeScript obrigatório, evitar `any`
4. ✅ **Validação**: Sempre validar dados de entrada
5. ✅ **Segurança**: JWT, RBAC, criptografia, nunca logar dados sensíveis
6. ✅ **Testes**: Cobertura mínima 70%, testes independentes
7. ✅ **Performance**: Índices, paginação, cache, evitar N+1
8. ✅ **Documentação**: JSDoc, Swagger, READMEs
9. ✅ **Commits**: Atômicos, mensagens descritivas, formato padronizado
10. ✅ **Code Review**: Obrigatório antes de merge

---

**Última atualização**: 2024-01-XX  
**Versão**: 1.0.0
